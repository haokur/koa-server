{"version":3,"file":"download-DdP7UEpp.js","sources":["../../pages/download/download.vue"],"sourcesContent":["<template>\n    <div class=\"download\">\n        <input type=\"text\" v-model=\"fileName\" />\n        <el-button @click=\"downloadFileByUrl\">开始分片下载</el-button>\n    </div>\n</template>\n<script lang=\"ts\" setup>\nimport { reactive, ref } from 'vue';\nimport axios from 'axios';\nimport { AsyncQueue } from '../../classes/AsyncQueue';\n\nconst ChunkSize = Math.floor(0.4 * 1024 * 1024);\nconst fileName = ref('f1708607957313.png');\nconst currentDownloadObj = reactive<{\n    fileName: string;\n    fileUrl: string;\n    fileRemoteUrl: string;\n    /**整个文件的大小 */\n    totalFileSize: number;\n    chunkSize: number;\n    chunkRanges: {\n        start: number;\n        end: number;\n        /**0未下载，1下载中，2下载已完成 */\n        status: 0 | 1 | 2;\n        index: number;\n    }[];\n    chunkRangeData: ArrayBuffer[];\n}>({\n    fileName: '',\n    fileUrl: '',\n    fileRemoteUrl: '',\n    totalFileSize: 0,\n    chunkSize: ChunkSize,\n    chunkRanges: [],\n    chunkRangeData: [],\n});\n\nconst downloadFileByUrl = () => {\n    if (!fileName.value) return;\n    if (fileName.value !== currentDownloadObj.fileName) {\n        Object.assign(currentDownloadObj, {\n            fileName: fileName.value,\n            fileRemoteUrl: '',\n            totalFileSize: 0,\n            chunkSize: ChunkSize,\n            chunkRanges: [],\n            chunkRangeData: [],\n        });\n    }\n\n    const url = `${$env.baseUrl}/file/download?fileName=${fileName.value}`;\n\n    downloadFile(url);\n};\n\nasync function allDownloadCallback() {\n    // 拼接下载后的数据\n    const fileBufferData = currentDownloadObj.chunkRangeData.reduce(\n        (prev: ArrayBuffer[], current: ArrayBuffer) => {\n            return [...prev, current];\n        },\n        []\n    );\n\n    const blob = new Blob(fileBufferData);\n    const downloadUrl = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = downloadUrl;\n    a.download = 'downloaded_file.png';\n    document.body.appendChild(a);\n    a.click();\n    URL.revokeObjectURL(downloadUrl);\n}\n\n// 开始按段请求下载\nconst maxConcurrent = 2;\nconst conQueue = new AsyncQueue(maxConcurrent, true);\nconQueue.finishCallback = allDownloadCallback;\n\nasync function setDownloadInfo(url) {\n    // 先试用HEAD方式仅获取文件大小\n    const response = await axios.head(url);\n    const contentLength: any = response.headers['content-length'] || '0';\n    const totalSize = parseInt(contentLength);\n    currentDownloadObj.totalFileSize = totalSize;\n\n    // 按size和chunkSize进行分段\n    let prevEndSize = -1;\n    let index = 0;\n    while (prevEndSize < totalSize) {\n        const startSizeIndex = prevEndSize + 1;\n        const endSizeIndex = prevEndSize + currentDownloadObj.chunkSize;\n        currentDownloadObj.chunkRanges.push({\n            start: startSizeIndex,\n            end: endSizeIndex,\n            status: 0,\n            index,\n        });\n        prevEndSize = endSizeIndex;\n        index++;\n    }\n}\n\nasync function downloadFile(url) {\n    if (url !== currentDownloadObj.fileUrl) {\n        conQueue.clear();\n        currentDownloadObj.fileUrl = url;\n        await setDownloadInfo(url);\n    }\n\n    const queueCallback = async (taskItem) => {\n        let { index, start, end } = taskItem;\n        const chunk = await fetchChunk(url, start, end);\n        currentDownloadObj.chunkRangeData[index] = chunk;\n    };\n    conQueue.addManyTask(currentDownloadObj.chunkRanges, queueCallback);\n    conQueue.run();\n}\n\n// 按分段数据拼接\nasync function fetchChunk(url, start, end) {\n    const response = await fetch(url, {\n        headers: {\n            Range: `bytes=${start}-${end}`,\n        },\n    });\n    const arrayBuffer = await response.arrayBuffer();\n    return arrayBuffer;\n}\n</script>\n<style lang=\"scss\" scoped></style>\n"],"names":["maxConcurrent","ChunkSize","fileName","ref","currentDownloadObj","reactive","downloadFileByUrl","url","define_env_default","downloadFile","allDownloadCallback","fileBufferData","prev","current","blob","downloadUrl","a","conQueue","AsyncQueue","setDownloadInfo","contentLength","axios","totalSize","prevEndSize","index","startSizeIndex","endSizeIndex","queueCallback","taskItem","start","end","chunk","fetchChunk"],"mappings":"gPA4EMA,EAAgB,kCAjEtB,MAAMC,EAAY,KAAK,MAAM,QAAiB,EACxCC,EAAWC,EAAI,oBAAoB,EACnCC,EAAqBC,EAexB,CACC,SAAU,GACV,QAAS,GACT,cAAe,GACf,cAAe,EACf,UAAWJ,EACX,YAAa,CAAC,EACd,eAAgB,CAAC,CAAA,CACpB,EAEKK,EAAoB,IAAM,CACxB,GAAA,CAACJ,EAAS,MAAO,OACjBA,EAAS,QAAUE,EAAmB,UACtC,OAAO,OAAOA,EAAoB,CAC9B,SAAUF,EAAS,MACnB,cAAe,GACf,cAAe,EACf,UAAWD,EACX,YAAa,CAAC,EACd,eAAgB,CAAC,CAAA,CACpB,EAGL,MAAMM,EAAM,GAAGC,EAAK,OAAO,2BAA2BN,EAAS,KAAK,GAEpEO,EAAaF,CAAG,CAAA,EAGpB,eAAeG,GAAsB,CAE3B,MAAAC,EAAiBP,EAAmB,eAAe,OACrD,CAACQ,EAAqBC,IACX,CAAC,GAAGD,EAAMC,CAAO,EAE5B,CAAC,CAAA,EAGCC,EAAO,IAAI,KAAKH,CAAc,EAC9BI,EAAc,IAAI,gBAAgBD,CAAI,EACtCE,EAAI,SAAS,cAAc,GAAG,EACpCA,EAAE,KAAOD,EACTC,EAAE,SAAW,sBACJ,SAAA,KAAK,YAAYA,CAAC,EAC3BA,EAAE,MAAM,EACR,IAAI,gBAAgBD,CAAW,CACnC,CAIA,MAAME,EAAW,IAAIC,EAAWlB,EAAe,EAAI,EACnDiB,EAAS,eAAiBP,EAE1B,eAAeS,EAAgBZ,EAAK,CAGhC,MAAMa,GADW,MAAMC,EAAM,KAAKd,CAAG,GACD,QAAQ,gBAAgB,GAAK,IAC3De,EAAY,SAASF,CAAa,EACxChB,EAAmB,cAAgBkB,EAGnC,IAAIC,EAAc,GACdC,EAAQ,EACZ,KAAOD,EAAcD,GAAW,CAC5B,MAAMG,EAAiBF,EAAc,EAC/BG,EAAeH,EAAcnB,EAAmB,UACtDA,EAAmB,YAAY,KAAK,CAChC,MAAOqB,EACP,IAAKC,EACL,OAAQ,EACR,MAAAF,CAAA,CACH,EACaD,EAAAG,EACdF,GACJ,CACJ,CAEA,eAAef,EAAaF,EAAK,CACzBA,IAAQH,EAAmB,UAC3Ba,EAAS,MAAM,EACfb,EAAmB,QAAUG,EAC7B,MAAMY,EAAgBZ,CAAG,GAGvB,MAAAoB,EAAgB,MAAOC,GAAa,CACtC,GAAI,CAAE,MAAAJ,EAAO,MAAAK,EAAO,IAAAC,CAAA,EAAQF,EAC5B,MAAMG,EAAQ,MAAMC,EAAWzB,EAAKsB,EAAOC,CAAG,EAC3B1B,EAAA,eAAeoB,CAAK,EAAIO,CAAA,EAEtCd,EAAA,YAAYb,EAAmB,YAAauB,CAAa,EAClEV,EAAS,IAAI,CACjB,CAGe,eAAAe,EAAWzB,EAAKsB,EAAOC,EAAK,CAOhC,OADa,MALH,MAAM,MAAMvB,EAAK,CAC9B,QAAS,CACL,MAAO,SAASsB,CAAK,IAAIC,CAAG,EAChC,CAAA,CACH,GACkC,aAEvC"}