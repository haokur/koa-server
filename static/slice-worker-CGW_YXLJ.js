var I=Object.defineProperty;var x=(c,e,s)=>e in c?I(c,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):c[e]=s;var d=(c,e,s)=>x(c,typeof e!="symbol"?e+"":e,s);import{d as T}from"./file.util-C4gPpxdd.js";import{d as E,c as N,a as t,F as B,e as A,p as P,q as S,g as z,_ as W}from"./index-DyJsfi6i.js";class C{constructor(e,s){d(this,"channels",[]);d(this,"tasks",[]);d(this,"channelMaxNum",0);d(this,"channelInit");d(this,"finishCallback");d(this,"isPause",!1);this.channelMaxNum=e,this.channelInit=s}onFinished(e){return this.finishCallback=e,this}addManyTasks(e,s){return this.tasks=e.map((r,k)=>({task:r,callback:s,status:0,index:k})),this}checkChannel(){if(!(this.channels.length>=this.channelMaxNum)&&this.channels.length<this.tasks.length){const s=Math.min(this.tasks.length,this.channelMaxNum);for(let r=this.channels.length;r<s;r++)this.channels.push({index:r,status:0,channelInstance:this.channelInit()})}}runTask(){this.isPause||(this.checkChannel(),!this.tasks.length&&this.channels.every(e=>e.status===0)&&this.finishCallback&&this.finishCallback(),this.channels.forEach(e=>{if(e.status===0&&this.tasks.length){e.status=1;const s=this.tasks.shift(),{task:r,callback:k,index:b}=s;s.status=1,k(e,r,b).then(()=>{e.status=0,s.status=2,this.runTask()})}}))}run(){return this.isPause=!1,this.runTask(),this}pause(){this.isPause=!0}clear(){this.isPause=!0,this.tasks=[],this.channels=[]}}function q(){return Date.now().toString(36)+Math.random().toString(36).substr(2)}class M{constructor(e){d(this,"resolves");d(this,"worker");this.worker=new Worker(e),this.worker.onmessage=this.handleMessage.bind(this),this.worker.onerror=this.handlerError.bind(this),this.resolves=new Map}handleMessage(e){const{_id:s,payload:r}=e.data;this.resolves.has(s)&&(this.resolves.get(s)(r),this.resolves.delete(s))}handlerError(e){console.log("webworker error",e)}postMessage(e){return new Promise(s=>{const r=q(),k={_id:r,payload:e};this.worker.postMessage(k),this.resolves.set(r,s)})}}const m=c=>(P("data-v-8f8e82a3"),c=c(),S(),c),D=m(()=>t("div",{class:"mb20 intro"},[z(" 实测发现： "),t("p",null,"1、在小文件，少文件，使用同步处理的时间会更优于使用webworker处理，因为开启webworker会有损耗，通信也会有消耗"),t("p",null,"2、使用webworker不会阻塞渲染进程，在进行slice时，不会阻碍刷新渲染"),t("p",null,"3、当处理的量级上去之后，比如8个大文件要进行切割，使用webworker的优势才开始显现"),t("p",null,"4、打开控制台，可以看到console.time打印的耗时")],-1)),L={class:"slice-worker"},V={class:"mb20"},j=m(()=>t("label",{for:""},"直接文件切割",-1)),G={class:"mb20"},H=m(()=>t("label",{for:""},"webworker文件切割-任务大数组",-1)),U={class:"mb20"},J=m(()=>t("label",{for:""},"webworker文件切割-任务二维数组（减少webworker通信）",-1)),K={class:"mb20"},O=m(()=>t("label",{for:""},"多文件同步slice",-1)),Q={class:"mb20"},R=m(()=>t("label",{for:""},"多文件webworker-slice",-1)),v=.4*1024*1024,X=E({__name:"slice-worker",setup(c){const e=i=>{const a=Math.ceil(i.size/v),l=navigator.hardwareConcurrency||4;let o=[];for(let n=0;n<a;n++)o.push({index:n,start:n*v,end:Math.min((n+1)*v,i.size)});return{allTasks:o,workerNum:l}},s=async i=>{const a=i.target.files[0],{allTasks:l}=e(a);console.time("普通切割耗时：");for(let o=0;o<l.length;o++){let{start:n,end:h}=l[o];a.slice(n,h)}console.timeEnd("普通切割耗时：")},r=async i=>{const a=i.target.files[0],{allTasks:l,workerNum:o}=e(a),n=[];console.time("webworker，任务不分组切割");const h=new C(o,()=>new M("/static/slice-helper.ts")).onFinished(()=>{console.timeEnd("webworker，任务不分组切割"),T(n,a.name),h.clear()}).addManyTasks(l,async(w,g,f)=>{const p=w.channelInstance,{start:u,end:_}=g;let y=await p.postMessage({action:"sliceFile",file:a,start:u,end:_});n.push(y)}).run()},k=async i=>{const a=i.target.files[0],{allTasks:l,workerNum:o}=e(a),n=[];let h=Math.ceil(l.length/o);for(let f=0;f<o;f++){let p=[];for(let u=0;u<h;u++){let _=f*h+u;l[_]&&p.push(l[_])}n.push(p)}console.time("webworker任务分组切割");const w=[],g=new C(o,()=>new M("/static/slice-helper.ts")).onFinished(()=>{console.timeEnd("webworker任务分组切割");let f=w.reduce((p,u)=>p.concat(u),[]);T(f,a.name),g.clear()}).addManyTasks(n,async(f,p,u)=>{let y=await f.channelInstance.postMessage({action:"sliceFileMany",file:a,chunks:p});w[u]=y}).run()},b=async i=>{const a=i.target.files;console.time("普通切割耗时："),Array.from(a).forEach(l=>{const{allTasks:o}=e(l);for(let n=0;n<o.length;n++){let{start:h,end:w}=o[n];l.slice(h,w)}}),console.timeEnd("普通切割耗时：")},F=async i=>{const a=i.target.files,l=Array.from(a);console.time("webworker，按文件分别分组切割"),new C(8,()=>new M("/static/slice-helper.ts")).onFinished(()=>{console.timeEnd("webworker，按文件分别分组切割")}).addManyTasks(l,async(o,n,h)=>{const w=o.channelInstance,{allTasks:g}=e(n);await w.postMessage({action:"sliceFileByTasks",file:n,allTasks:g})}).run()};return(i,a)=>(A(),N(B,null,[D,t("div",L,[t("div",V,[j,t("input",{type:"file",onChange:s},null,32)]),t("div",G,[H,t("input",{type:"file",onChange:r},null,32)]),t("div",U,[J,t("input",{type:"file",onChange:k},null,32)]),t("div",K,[O,t("input",{type:"file",multiple:"",onChange:b},null,32)]),t("div",Q,[R,t("input",{type:"file",multiple:"",onChange:F},null,32)])])],64))}}),ee=W(X,[["__scopeId","data-v-8f8e82a3"]]);export{ee as default};
